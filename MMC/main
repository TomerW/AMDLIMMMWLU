from __future__ import annotations

from pathlib import Path
from typing import Any, Dict
import math
import os

from fastapi import FastAPI, HTTPException, Request
import httpx
from jsonschema import Draft202012Validator
from jsonschema.exceptions import ValidationError
import uvicorn


SCHEMA_PATH = Path(__file__).with_name("mmc_orders.schema.json")


def _load_schema() -> Dict[str, Any]:
	if not SCHEMA_PATH.exists():
		raise FileNotFoundError(f"Schema file not found: {SCHEMA_PATH}")
	return SCHEMA_PATH.read_text(encoding="utf-8")


def _parse_schema_text(text: str) -> Dict[str, Any]:
	import json

	return json.loads(text)


ROOT_SCHEMA = _parse_schema_text(_load_schema())


def _schema_for(def_name: str) -> Dict[str, Any]:
	return {
		"$schema": ROOT_SCHEMA.get("$schema"),
		"$ref": f"#/$defs/{def_name}",
		"$defs": ROOT_SCHEMA.get("$defs", {}),
	}


def _validate(def_name: str, payload: Dict[str, Any]) -> None:
	schema = _schema_for(def_name)
	validator = Draft202012Validator(schema)
	errors = sorted(validator.iter_errors(payload), key=lambda e: e.path)
	if errors:
		details = [" -> ".join([str(p) for p in error.path]) + ": " + error.message for error in errors]
		raise HTTPException(status_code=400, detail=details)


def _azimuth_from_north_east(north: float, east: float) -> int:
	angle_rad = math.atan2(east, north)
	angle_deg = (math.degrees(angle_rad)+360) % 360
	return int(round(angle_deg)) % 360


def _azimuth_in_range(current: int, target: int, tolerance: int = 5) -> bool:
	delta = (current - target + 180) % 360 - 180
	return abs(delta) <= tolerance


app = FastAPI(title="MMC", version="1.0.0")

TURRET_BASE_URL = os.getenv("TURRET_BASE_URL", "http://172.20.10.4:5000")
MUC_BASE_URL = os.getenv("MUC_BASE_URL", "http://127.0.0.1:4000")
BMC_BASE_URL = os.getenv("BMC_BASE_URL", "http://172.20.10.3:5000")

state: Dict[str, Any] = {
	"last_target": None,
	"fire_command": None,
	"missile_lock": None,
	"lock_command": None,
	"azimuth_command": None,
	"current_azimuth": None,
}


@app.post("/bmc/target")
async def bmc_target(request: Request) -> Dict[str, str]:
	payload = await request.json()
	_validate("TargetMessage", payload)
	print(f"Received BMC target: {payload}")
	state["last_target"] = payload
	azimuth_command = {
		"azimuth_command": _azimuth_from_north_east(
			payload["position_north"],
			payload["position_east"],
		),
	}
	_validate("AzimuthCommand", azimuth_command)
	state["azimuth_command"] = azimuth_command
	try:
		async with httpx.AsyncClient(timeout=5.0) as client:
			response = await client.post(
				f"{TURRET_BASE_URL}/turret/azimuth-command",
				json=azimuth_command,
			)
			response.raise_for_status()
			print(f"Sent Turret azimuth command: {azimuth_command}")
	except httpx.HTTPError as exc:
		raise HTTPException(status_code=502, detail=f"Turret command failed: {exc}") from exc
	return {"status": "OK"}


@app.post("/bmc/fire-command")
async def bmc_fire_command(request: Request) -> Dict[str, str]:
	payload = await request.json()
	_validate("FireCommand", payload)
	print(f"Received BMC fire-command: {payload}")
	state["fire_command"] = payload
	return {"status": "OK"}


@app.post("/bmc/status")
async def bmc_status(request: Request) -> Dict[str, str]:
	payload = await request.json()
	_validate("MissileLockStatus", payload)
	print(f"Received BMC status: {payload}")
	state["missile_lock"] = payload
	return {"status": "OK"}


@app.post("/muc/lock-command")
async def muc_lock_command(request: Request) -> Dict[str, str]:
	payload = await request.json()
	_validate("LockCommand", payload)
	print(f"Received MUC lock-command: {payload}")
	state["lock_command"] = payload
	return {"status": "OK"}


@app.post("/muc/lock-status")
async def muc_lock_status(request: Request) -> Dict[str, str]:
	payload = await request.json()
	_validate("MissileLockStatus", payload)
	print(f"Received MUC lock-status: {payload}")
	state["missile_lock"] = payload
	return {"status": "OK"}


@app.post("/turret/azimuth-command")
async def turret_azimuth_command(request: Request) -> Dict[str, str]:
	payload = await request.json()
	_validate("AzimuthCommand", payload)
	print(f"Received Turret azimuth-command: {payload}")
	state["azimuth_command"] = payload
	return {"status": "OK"}


@app.get("/turret/azimuth-command")
async def turret_azimuth_command_status() -> Dict[str, Any]:
	azimuth_command = state.get("azimuth_command")
	if azimuth_command is None:
		raise HTTPException(status_code=404, detail="Azimuth command not available")
	return azimuth_command


@app.post("/turret/azimuth-status")
async def turret_azimuth_status_report(request: Request) -> Dict[str, str]:
	payload = await request.json()
	_validate("AzimuthStatus", payload)
	state["current_azimuth"] = payload
	print(f"Turret azimuth status received: {payload}")
	current = payload.get("current_azimuth")
	if isinstance(current, int):
		bmc_payload = {"azimuth": current}
		try:
			async with httpx.AsyncClient(timeout=5.0) as client:
				response = await client.post(
					f"{BMC_BASE_URL}/api/turret/azimuth_update",
					json=bmc_payload,
				)
				response.raise_for_status()
				print(f"Sent BMC azimuth update: {bmc_payload}")
		except httpx.HTTPError as exc:
			raise HTTPException(status_code=502, detail=f"BMC azimuth update failed: {exc}") from exc
	azimuth_command = state.get("azimuth_command")
	if azimuth_command and "azimuth_command" in azimuth_command:
		commanded = azimuth_command.get("azimuth_command")
		if isinstance(current, int) and isinstance(commanded, int):
			if _azimuth_in_range(current, commanded, tolerance=5):
				lock_command = {"lock_command": "LOCK"}
				_validate("LockCommand", lock_command)
				state["lock_command"] = lock_command
				try:
					async with httpx.AsyncClient(timeout=5.0) as client:
						response = await client.post(
							f"{MUC_BASE_URL}/muc/lock-command",
							json=lock_command,
						)
						response.raise_for_status()
						print(f"Sent MUC lock-command: {lock_command}")
				except httpx.HTTPError as exc:
					raise HTTPException(status_code=502, detail=f"MUC lock command failed: {exc}") from exc
	return {"status": "OK"}


@app.get("/turret/azimuth-status")
async def turret_azimuth_status() -> Dict[str, Any]:
	current_azimuth = state.get("current_azimuth")
	if current_azimuth is None:
		raise HTTPException(status_code=404, detail="Azimuth status not available")
	return current_azimuth


if __name__ == "__main__":
	uvicorn.run(app, host="0.0.0.0", port=4000, reload=False)
